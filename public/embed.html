<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Embed Video</title>
  <meta name="robots" content="noindex, nofollow" />
  <meta name="referrer" content="origin">

  <!-- JWPlayer Library -->
  <script src="https://cdn.jwplayer.com/libraries/aVr2lJgW.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #000;
      color: #fff;
      height: 100vh;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #player-container {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
    }

    /* Loading Spinner */
    .loader {
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top: 4px solid #fff;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
      pointer-events: none;
    }
  </style>
</head>

<body>

  <div id="loading">
    <div class="loader"></div>
  </div>
  <div id="player-container"></div>

  <script>
    // --- Configuration ---
    const urlParams = new URLSearchParams(window.location.search);
    let VIDEO_ID = urlParams.get('id');
    const THUMBNAIL = urlParams.get('thumb') || '';

    // Base64URL Decode implementation for browser
    function base64UrlDecode(str) {
      try {
        str = str.replace(/-/g, '+').replace(/_/g, '/');
        while (str.length % 4) {
          str += '=';
        }
        return atob(str);
      } catch (e) {
        console.error("Error decoding ID:", e);
        return null;
      }
    }

    if (!VIDEO_ID) {
      document.body.innerHTML = '<div style="text-align:center; padding-top:20%">Video ID missing</div>';
    } else {
      // Decode the ID if it looks encoded (simple heuristic or just always decode if we assume all incoming are encoded)
      // Since we control the source, we can assume it's encoded.
      // However, to be backward compatible or safe, we might try to decode, and if it fails or looks weird, keep original?
      // But purely from "hiding" perspective, we should expect encoded.
      // Let's blindly decode.
      const decoded = base64UrlDecode(VIDEO_ID);
      if (decoded) VIDEO_ID = decoded;
      
      initPlayer();
    }

    async function initPlayer() {
      try {
        const sources = await fetchVideoSources(VIDEO_ID);
        if (sources && sources.length > 0) {
          setupJWPlayer(sources);
        } else {
          throw new Error("No sources found");
        }
      } catch (e) {
        console.error("Player initialization failed:", e);
        // Fallback or error message
        document.getElementById('loading').style.display = 'none';
        document.body.innerHTML += '<div style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%)">Video unavailable</div>';
      }
    }

    function setupJWPlayer(sources) {
      document.getElementById('loading').style.display = 'none';
      jwplayer("player-container").setup({
        sources: sources,
        image: THUMBNAIL,
        width: "100%",
        height: "100%",
        autostart: true,
        playbackRateControls: true,
        preload: "auto",
      });
    }

    // --- Scraper Logic (Client Side) ---
    // Rotates proxies to try and get the video source
    async function fetchVideoSources(id) {
      // Clean ID just in case
      const cleanId = id.replace(/\./g, "");

      const strategies = [
        `https://xvideos1-22731.kxcdn.com/embedframe/${cleanId}/`,
        `https://xvideos-22731.kxcdn.com/embedframe/${cleanId}/`
      ];

      const foundSources = [];
      const filesCheck = {}; // avoid duplicates

      // Try strategies sequentially until we get data
      for (const url of strategies) {
        try {
          console.log(`Trying to fetch sources from: ${url}`);
          const response = await fetch(url);
          if (!response.ok) continue;

          const html = await response.text();

          // Regex patterns from the original script
          parseSource(html, /setVideoHLS\(\'(.*)\'/g, 'HLS', 'hls', filesCheck, foundSources);
          parseSource(html, /setVideoUrlHigh\(\'(.*)\'/g, 'High Quality', 'video/mp4', filesCheck, foundSources);
          parseSource(html, /setVideoUrlLow\(\'(.*)\'/g, 'Low Quality', 'video/mp4', filesCheck, foundSources);

          if (foundSources.length > 0) break; // Stop if we found something
        } catch (e) {
          console.warn(`Failed strategy ${url}`, e);
        }
      }

      return foundSources;
    }

    function parseSource(html, regex, label, type, checkMap, results) {
      const match = regex.exec(html);
      if (match && match[1] && match[1].startsWith('http')) {
        const src = match[1];
        if (!checkMap[label]) {
          checkMap[label] = true;
          results.push({
            file: src,
            label: label,
            type: type
          });
        }
      }
    }
  </script>
</body>

</html>